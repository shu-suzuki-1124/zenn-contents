---
title: "（仮）ソシュールの記号論とプログラミング言語と現代社会について"
emoji: "🔖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["言語学", "ソシュール", "言語理論", "記号学", "プログラミング言語"]
published: false
---

> ひとが学びうるのは、ただ哲学することのみである。すなわち、理性の才能を、その普遍的原理を遵守しながら、目のまえにある或る種の試行にそくして訓練することだけである  
「純粋理性批判」イマヌエル・カント [1]

## 目次

0. はじめに
1. 記号とはなにか: 一般言語学講義とソシュールの記号論
2. 記号の再帰性とプログラミング言語
3. メディアとシステム社会論の記号論的把握
4. エンジニア世界の再構築
5. まとめ

## 0. はじめに

### 0-1 エンジニアの世界における命題的正しさに関する問いについて

#### 0-1-1 論理学における命題/推論の区別

論理学においては基本的なことだが、命題の正しさと演繹・推論の正しさは峻別される。

例えば、「お寿司は洋食である、洋食はフォークとナイフで食べる、ならばお寿司はフォークとナイフで食べる」という文章について考えてみよう。我々はお寿司が和食であることを経験的に知っているので、この文章は間違いだと感じる。一方、A:「お寿司」,B: 「洋食」, C: 「フォークとナイフで食べる」とすると、A=B, B=CならばA=Cという論理の推論に間違いはない。よってこのことからもわかるように、命題の正しさと推論の正しさは別に考えなければならない。

#### 0-1-2 エンジニア世界における命題的/推論的な問題

すべてにおいてこの論理学的な考え方があてはまるとはいえないが、あえてこの形式で我々のエンジニアの世界について考えてみたい。エンジニア世界とはここでは、エンジニアが職業エンジニアに広く普及している一般的な慣習や認識を通してみた世界の在り方と考えていただいて差し支えない。

まず推論的正しさについてであるが、エンジニアの世界は数学や物理をはじめとする自然科学中心の世界であり、自然科学的手法の追求はまさしく推論的な正しさを探求することに相違ないといえよう。例えばコンピュータサイエンスにおいてアルゴリズム問題はまさしく推論手順の問題であるし、物理学における理論の検証法もそうである。

一方命題の正しさはどうであろうか。自然科学の世界において、特定の命題の正しさは閉じられた環境での実験や観測によって確認されるため、ほとんどの場合所与とみなされる。例えばプログラミングにおいて、「処理速度が高いほうがよい」といった命題の正しさは疑う余地はない。

しかし自然科学、コンピュータサイエンスの外の世界を含めて考えると、この命題的正しさの妥当性は決め難くなる。例えば、コードをチューニングして処理速度が数倍良くなったとしよう。ただ、それによってユーザーにとって快適になり、アプリケーションにのめり込む時間が増えるかもしれない。ビジネス的にはきっといいことだが、もしこれがユーザーが本来別のことに使う時間（例えば運動、家族との時間など）を奪ってしまい、そのことによって長期的にみるとユーザーの幸福度を下げてしまう可能性があるならば、「処理速度が高いほうがよい」という命題は常に正しいとは言い難くなる（もちろんこれによってユーザーがアプリに使う時間が減ってプラスになることもあることも否定できないが...）。

#### 0-1-3 エンジニア世界における意味の問題を考える

このように命題的正しさは、自然科学が前提にしている実験室などの閉じられた環境でないならば、簡単に決められるものではない。しかしだからといって命題的正しさを考えることを放棄してはならない。それは、命題的正しさを求める問いは、まさしく意味を考えることであるからだ。エンジニアの多くは、「この仕事、プログラミングは意味あるだろうか」「生成AIが誕生した世の中で働く意味はあるだろうか」みたいな意味の問いを一度は考えたことはあるのではなかろうか。

エンジニア世界を取り囲む自然科学的な性質で、推論的な正しさに関する問いは常に考えられてきた。しかし、一方命題的正しさ、つまり意味そのものにおける問題はそうではないと個人的には感じる。技術の在り方は自然科学の前提にあるような閉じられた環境でおさまるものではなく、そして多くのエンジニアがビジネス世界で働き、技術と社会・技術と人間が密接に関わる世の中であるので、こういった命題的な正しさを改めて追求するのは決して悪くはないだろう。

ゆえに本記事はまさしく、エンジニア世界における命題的正しさ、すなわちエンジニア世界における意味の在り方について書く。気をつけてほしいのは、具体的な意味の問題、「こういうエンジニアの仕事には意味がある！一方でこっちの仕事は意味がない！」みたいなものを論じる気はない。むしろ意味をどう捉えうるかについて書いていくつもりだ。

### 0-2 社会科学的方法論と記号論の導入について

#### 0-2-1 社会科学における命題的なものの捉え方について

ではエンジニア世界における命題的正しさ、またその妥当性を考えるにあたってどのように考えていけばよいだろうか。自然科学とは別の領域の学問、社会科学における考え方をみていくことにしよう。

こういった命題/推論的な問いに関するような似たような問題は、社会科学の領域では別の言い方、すなわち主観的/客観的、経験的/科学的といった形で議論されている。まさしく命題的正しさに関する問いは、こういった言葉がある意味で誤解を生んでしまうかもしれないが、経験や主観的といった言葉にカテゴライズされるようなものを内包するものといえよう。

そしてこういった主観や経験と言われる領域のものからは決して逃れることができないというのが、社会科学的な考え方といえる。たとえば、エドワード・ハレット・カーの『歴史とはなにか』[2]において、歴史家を「行列の行進」にたとえる箇所がある。

> もちろん隠喩ですが、ただし歴史家のみなさん、ご自分はあたかも絶壁から様子をうかがう鷲か、観閲台で敬礼しているVIPであるかのうような気持ちにはなられませんよう。全然違うのです[笑]。歴史家はじつは行列の中でとぼとぼ歩いている冴えない一人にすぎないのです。

なんとも面白いたとえだが、カーはここで歴史家がどんな客観的な事実を追っているようにみえても、歴史家個人の価値、すなわち数あるなかから何を歴史の大事な要素として選別し解釈するか、そういったものからは切り離せないと主張している。ゆえに現代的な価値から過去を見るという点で、歴史とは`現在と過去の終わりない対話`であるというのである。

また社会学においては、マックス・ウェーバー『職業としての学問』[3]として、学問について以下のようにある。

> 今日、学問は自己省察と事実連関の認識に奉仕して専門的に営まれる「仕事」です。

ウェーバーにおいては、「価値解釈」に関する問題は客観性論文[4]にも現れているが、学問においても、社会問題を取り上げるにしても無前提ということは決してあり得ないとしている。

しかしこれらが社会科学の学問が無意味であるとか、不正確であるとかは決して意味しない。カーにおいても正確性は義務であるとしているし、ウェーバーの統計的因果推論の手法はまさしく厳密性そのものであるし、主観/客観の対立で主観的なものを悪いとみなすことが間違いである。近年の社会科学の手法でもある、ベイズ統計やランダム化比較試験は主観/客観的な対立という枠におさまるものではない[5]。

こういった社会科学的学問を通していえるのが、我々は意味の問題を考える時に、なにがしかの価値前提から逃れることはできないし、そういった価値前提こそ意味の問題である。であればそれを自己反省的に意味をどう把握しているかを捉えることが大事なのである。

#### 0-2-2 コンピュータサイエンスと社会科学をつなぐ記号論

とするならば、我々はエンジニア世界にいながらエンジニア世界の意味の問題について考えるわけであり、そういった価値の問題からは逃れることはできない。また、社会科学的視点でみるからといってそれはコンピュータサイエンス的な観点を無視してよいわけではない。エンジニア世界はビジネス、人間、社会といったものとコンピュータとの接合的な世界だからである。

そのためエンジニア世界の意味の問題を考えるにあたり少し工夫する。それが記号論である。

記号とは特定の対象を指し示すもの、特定の意味を表すもののことである。なので記号の性質を明らかにすることは、意味についての問題を明らかにすることと同義である。一方、プログラミング言語はまさしく記号であるし、また現代社会はメディアを中心とする情報社会という表現が良くされるが、情報もまさしく記号として捉えることが可能である。よって記号を使えばコンピュータから社会科学まで一貫した方法で考えることができる。

なのでこの記事では記号をその話題の中心として据えて、意味の問題について考えていく。

#### 0-2-3 記号論と構造主義

記号論というと、少し前に流行した構造主義という思想の流行があったことが思い出される。この記事でもある程度そういった構造主義的なものの見方をすることになるだろう。一方、構造主義は静的な構造に支配されている、主体性の欠如といった意味で批判にさらされることも多い。構造主義の思想を読むと決してそんなことはないのだが、そういった従来の構造主義批判を乗り越える意味でも改めて記号論を考えていきたいと個人的に思っている。

もちろんこの記号的視点は絶対的なものではないし、むしろ記号論的にすべてをあてはめる汎記号主義的なバイアスは避けられないだろう。しかしそれでも意味の問題を考えるうえで記号論的視点は新しい視野を切り開いてくれると信じている。

### 0-3 記事の構成と全体像

主にこの記事は4部構成になっている。以下1部ずつ概要を説明する。

#### 0-3-1 1部: 記号とはなにか: 一般言語学講義とソシュールの記号論

1部で述べるのは、記号の性質と認識の言語論的転回についてである。

まずはソシュールの言語論を通して記号とは一体なにか、記号の性質とはなにかについて考えていく。ソシュールは近代言語学の父とも呼ばれ、言語学を記号学として位置づけた。そうしたソシュールの記号学は、記号の性質を明らかにするとともに、認識の言語論的転回を起こすものだった。言語論的転回とは、もとは言語哲学で言われた思想転回のことを指すが、ソシュールの記号学はまさしく、モノ自体の認識という従来の認識論の在り方を変革し、世界を記号によって分節し把握する関係論的認識といえるだろう。この記号学の関係論において意味がどう生み出されるかを考えていく。

#### 0-3-2 2部: 記号の再帰性とプログラミング言語

2部で述べるのは、プログラミング言語と記号の再帰性についてである。

1部でみたソシュールの記号学とは別に新たにパースの記号論を紹介する。ソシュールの記号学が二元論的であるのに対し、パースの記号論は三元論的である。ソシュールとパースの記号論を比較・統合し、プログラミング言語を記号論として考えていく。自然言語で考えられた記号の考察がプログラミング言語においても当てはまり、またプログラミング言語だからこそ明らかになる再帰的な記号の性質を深ぼっていく。

#### 0-3-3 3部: メディアとシステム社会論の記号論的把握

３部で述べるのは、記号論をベースにした再帰的なシステム社会についてである。

1,2部までで記号論的な考え方と再帰的な記号の性質を見てきたが、その記号論における意味の捉え方で社会を捉えるとルーマンのシステム社会論につながっていくことを考える。ルーマンの自己産出、機能分化的な社会システムの捉え方は記号論的まさしく記号論的認識であり、2部でみたプログラミング言語の記号性をもとに、ルーマンの社会システムの唯一の要素であるコミュニケーションのなかに、プログラミングも位置づけることでエンジニア世界の意味論が展開できるようになる。

#### 0-3-4 4部: エンジニア世界の再構築

skip: 1~3部をふまえて、エンジニア世界を再定義し私自身の感想を述べる

## 1. 記号とはなにか: 一般言語学講義とソシュールの記号論

第一部ではソシュールの『一般言語学講義』[6] をもとに記号がどう成り立っているか、記号の性質とは何かについて考えていく。ソシュールの記号学は言語学的なものであるので、自然言語、日常会話における言語を対象としている。ゆえにイメージがしやすく、記号学の導入には丁度良いと思える。

もちろん『一般言語学講義』の内容を全部紹介できないので、以下の要点に絞って紹介する。

```console
① 言語学は記号学に位置づけられる
② 言語記号は所記と能記から成る
③ 言語記号は恣意的である
④ 世界は記号の差異によって分節される
```

### 1-0 ソシュールと一般言語学講義について

#### 1-1-1 ソシュールとその生涯について

『一般言語学講義』の内容に入る前に、ソシュールと『一般言語学講義』について軽く説明する。

フェルディナン・ド・ソシュールは1857年生まれであり、デュルケームやフロイトとほぼほぼ同年代であるので、第一次世界大戦前後のヨーロッパを生きた人である。

ソシュールはスイスの名家の生まれで、幼い頃より言語学の才能を開花させていった。経歴としては、ライプツィヒへの留学、パリでの講師を経て、最後はジュネーブ大学の言語学の教授となる。『一般言語学講義』とはそのジュネーブ大学での講義についての内容になる。

#### 1-1-2 一般言語学講義とは一体どんな書物か

上記の記述でもわかるとおり、『一般言語学講義』とはソシュールの著作ではない。

簡単にいえば、ジュネーブ大学の講義の内容を聞いた生徒たちが、講義メモをもとに本にまとめたのが『一般言語学講義』である。ただ、ソシュールの『一般言語学講義』にまつわる思想は、ソシュールの弟子たちも完全に理解はできなかった。上記の性質のために『一般言語学講義』の内容に関しては、多くの解釈や混乱がみられる。[7]

しかしそれでもソシュールの思想は重要であり、言語学だけでなく哲学・思想といった領域に重大な影響を与えた。

### 1-2 記号学としての言語学

#### 1-2-1 記号としての言語

『一般言語学講義』には以下のような文がある。

> なにをさしおいてもまず言語の土地の上に腰をすえ、これをもって言語活動の他のいっさいの現れの規範とすべきである。

ソシュールのいう「言語の土地」とは、まさしく記号体系としての言語である。

では記号体系としての言語とは何であろうか。それは社会的性質を持つことと実体のないことを指す。

前者の社会的性質はまさしく記号が他者との関係性によって意味を成すことである。他者の集合である社会で受容された記号だからこそ、その記号を使って他者に自分の考えを伝えることができるし、反対に他者の考えも理解できる。後者の実体がないことは、あとで詳しく述べるが、社会的に受容された記号はある音とある概念が自分の頭の中で結びつく概念のことを示す。反対に実体的な言葉自体は、それがにどう受容されるかは定かではないという点でそこまで重要ではない。

上記の社会的で実体のない記号としての言語を以降本記事では、<言語>と記す。一方具体的な言葉にあたるものを<言>と記す。

#### 1-2-2 共時的言語と通時的言語

ソシュールいわく、言語学は通時言語学と共時言語学にわけられるという。

通時とは時間的変遷のことで、簡単にいえば言語が時代が変わるにつれてどう変わっていったかを探求することである。一方共時とは一時代における言語全体の使われ方のことである。以下共時的と通時的を表す図である。

![lang](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/18db8ffb-94d2-43f6-a47e-7130b04d6907)

ABを同時性の軸、CDを継起性の軸とする。なぜこの区別する必要があるかというと、これらは全く別の学問であるからである。それは経済学では労働と貨幣論（同時性）と経済史（継起性）、経営学も組織論や戦略論（同時性）と経営史（継起性）では全く異なる学問となる。

言語学においては、継起性は言語が時代1から時代2それは1つの言語が別の要素に置き換わる1つの事件的なものである。一方、同一の時代で使われる言語状態の体系は集団内で言語がどう使われているかという心理的・論理的価値を表す。

ゆえに同時性を表す言語学は価値に直結し、まさしく記号学的といえる。

プログラミング言語でいえばバージョンアップのコミット履歴を追うのが通時的であり、ある特定のバージョンでの仕様が共時的である。

### 1-３ 記号の性質

#### 1-3-1 能記（シニフィアン）と所記（シニフィエ）

以下序説3章の言語学の対象の中の、人間事象における言語の位置. 記号学からの引用である。

> 言語は観念を表現する記号の体系であり、そうとすれば、書とか、指話法とか、象徴的儀式とか、作法とか、軍用記号とかと、比較されうるものである。

上記のようにソシュールは記号としての<言語>は観念とそれを表す表現から成る。ソシュールの言語学ではそれを能記と所記と表現する

```console
能記（シニフィアン）: 表現に関する要素
所記（シニフィエ）: 観念に関する要素
```

以下はイメージ図である。

![ki2 drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/92d5cb80-7456-42ea-a577-641cf1943295)

具体例でいうならば、<木>という概念は「き(ki)」という音と結びついている。ここでいう概念としての<木>が所記であり、「き(ki)」という音・表現が能記である。記号の役割はこの能記と所記を結びつける作用にあるといえる。

なお書籍によっては能記をシニフィアン、所記をシニフィエとそのまま表記することもある。これはシニフィアンが「意味するもの」ということで概念に結びついている感じであり、シニフィエが「意味されるもの」ということで表現に結びつかれているというニュアンスを残す。

ソシュールの思想的にはそちらのほうがわかりやすい部分もあるかもしれないが、本記事では参照している小林英夫氏の訳の能記と所記で書かさせていただく。

#### 1-3-2 記号の恣意性

ソシュールは記号としての<言語>における第一性質を恣意性としている。

> 能記を所記にむすびつける紐帯は、恣意的である、いいかえれば、記号とは、能記と所記との連合から生じた全体を意味する以上、いっそうかんたんいいうことができる:  言語記号は恣意的である。

先程の例でいえば、<木>という概念と「き(ki)」という音が結びつく必然性はないということである。同じような<木>の概念を英語では「tree」という音で表現している。このことからみても、記号としての<言語>の本質は恣意的だといえる。

### 1-4 価値体系と言語記号

#### 1-4-1 記号の消極的な差異性

<言語>の恣意性ともう一つ重要な原理は、差異性である。

> 言語には差異しかない

>言語には積極的辞項のない差異しかない。

この「積極的辞項のない差異」とは記号の恣意性から帰結できる性質である。記号における所記と能記が恣意的なのであれば、記号は相対的価値しか持たない。

仮に記号以前にモノそのものがあって、記号がそのモノを言い表すラベルなのであれば、記号の価値は絶対的である。一方、表現と内容が恣意的に結びつくのであれば、その音と内容の結び付きは偶然的なものであり、記号によって他の存在と区別する以上に価値は持たない。ソシュールの考えは後者であり、それゆえに「積極的辞項のない差異」とは記号は他と区別する以上の積極的役割はもたないことである。

#### 1-4-2 全体論的・関係論的な価値体系としての記号

では記号1つ１つが価値を持たないのであれば、記号による意味はどう生まれるのであろうかという疑問が湧いてくる。ソシュールの思想では、記号の価値や意味は他との記号の関係によって生じるのである。

以下イメージ図である（手書き）。

![lang](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/dd75d749-2578-4bb9-a319-82f690b64f5a)

ここで先程見たようにソシュール以前の考え方と対比して考える。ソシュール以前には仮にモノ自体があったとしたら、それが独自かつ個別に意味をなしていた。価値の体系は個別のモノの積み重ねによって成っているといっていいかもしれない。

一方ソシュールにとって記号とは消極的価値しかもたない。記号が価値を持つのは全体的な体系によってである。上記の図でいうと、ソシュールの思想では世界が記号によって分節される。その分節は記号の役割だが、この記号は区別的な消極的価値しかもたないので、他の記号との関連によって、または記号の全体論的な体系によって、意味、価値が生まれるのである。なので記号の区分けの仕方によって世界の見え方も異なってくる。

記号による分節は恣意的であり、それぞれの人間集団を取り巻く社会的価値などによって偶然的に決まる。よってこの考え方は記号の区別、すなわち記号の関係(の体系)によって世界を認識がされるという、いわば関係論的なものの見方なのである。

### 1-5 ソシュールの記号学における疑問点について

#### 1-5-1 記号は本当に恣意的であるのか

ソシュールの後継者ともいえるエミール・バンヴェニストは『一般言語学の諸問題』[8]で以下のように述べている。

> 記号の成分の一つは音響心像であって、能記を構成し、他は概念であって、すなわち所記である。能記と所記の間において、そのきずなは恣意的ではない。それどころか必然的なのである。

つまりソシュールの記号の恣意性を否定しているのである。バンヴェニストの主張は、いわば音と思考は切り離せないのだから、能記と所記のつながりは必然であり、恣意性というものがあるのであれば他の記号ではなく、この記号がある概念とつながっているという意味においてであるというものである。

ここに関しては2つ述べることがある。

1つめは上記の主張にも関わらず、やはり記号は恣意的であると思われる点である。バンヴェニストの主張によればソシュールの考えは能記と所記の二項に加えて、モノ自体を第三項の概念が入り込んでいるのではないかということである。そうすればモノ自体と音の結びつきは必然的であることになる。しかしこれについては差異の性質を述べたときにいった論理がその反論となる。

2つめは、恣意性が保たれるものの、ソシュールの思想の中で、記号はそれぞれ真逆の性質を内包しているという点で混乱しやすいという点である。

いくつか例がある。例えば絶対的恣意性と相対的恣意性である。記号は恣意的である一方で、社会的慣習等で有縁化されるのである。他の例は可易性と不易性である。<言語>は自分である程度自由に組み合わせられる（可易性）が、一方で相手に理解してもらうために組み合わせが制限される（不易性）。[9]

このようにソシュールの思想において、一見真逆に見える性質が記号に内包しているのである。この逆説は2部のプログラミング言語の記号論を考えるときの主題となる。

#### 1-5-2 記号論的な構造によって人間は支配されているのか

ソシュールは構造主義の祖と呼ばれている。ソシュールの以後、ヤーコブソンが音韻論[10]を中心にソシュールの言語学を引き継ぎ研究し、その言語学の手法に影響されたレヴィ・ストロースの人類・民族学[11] [12]の研究とサルトルとの論争を通して構造主義は思想の主流になった。なのでその源流はソシュールの思想にあるといっても過言ではない。

一方で構造主義という言葉にまとわりつくイメージ、すなわち閉じた構造としてのアポリアである。差異の体系で述べたように、記号はそれ自体ではなく全体論的な体系によって意味をつくる。それがいわば単一の物事の固有性がシステムによって同一的に支配されてしまうように感じてしまう。[13]

しかし『一般言語学講義』は時代背景もあり、共時的言語を重視しているが通時的な言語学を軽視しているわけでもない。また連辞（個々の語の意味と機能を決定する時間的または線的な関係）と連合（時間・空間から解放された意識の中で起こる連想）で不完全ながらも言語記号における変化に対する性質についても言及している[14]。レヴィ・ストロースにおける構造の概念も決して静態的なものでない。

記号論が静態的な構造における支配ではなく、意志作用による動態的な活動であることは3部以降でより不kがぼっていく。

#### 1-6 1部の総括

ソシュールの『一般言語学講義』を通して記号の性質、そして記号論的認識について考えてきた。記号は音や表現要素である能記、概念を表す所記によって成り、実体がなく恣意的で差異による消極的事項でしかない。記号が意味を持つのはそれは他の記号との関係、すなわち全体論的な体系によってであった。これはモノ自体があるのではなく、記号によって分節された世界を我々は認識しているという、認識における転回でもある。一方ソシュールの言語論には不可解なポイントもあり、逆説的なものを内包している。2部でこの逆説的な記号の性質をプログラミング言語と記号論の考え方を融合させつつ見ていきたい。

## 2. 記号の再帰性とプログラミング言語

第二部では1部でみた記号論をプログラミング言語において考える。プログラミング言語も言語の一種であるので、1部で自然言語で導出された内容はプログラミング言語にもあてはまるが、異なる部分もある。その相同性と共通性を鑑みながら比較していき、記号論をより深ぼっていく。

また、記号論の深堀りという側面もありつつ、エンジニア世界の意味の問題を考えるうえで、記号論とプログラミング言語を結びつけることは、我々エンジニアの普段の活動と意味の問題をより明確に考えることができるようになるだろう。

第２部では『記号と再帰』[15]の内容を中心に進めていく。『記号と再帰』は大きく三部構成になっており、①能記と所記の結びつきについて、②記号の内容の種類について、③記号系について、となっている。本記事もベースはこの構成で進めていく。キーワードとしては「再帰性」となるが、これは3部以降も重要なキーワードになる想定だ。

### 2-1 能記と所記をプログラミング言語で考える

#### 2-1-1 二元論と三元論

ソシュールの記号論は言語学において導かれたもので、言語学の領域を離れると記号論はソシュールのもの以外にも複数存在する。この様々な記号論は大別すると二元論と三元論に分類できる。

ソシュールの記号論は能記と所記から成るので二元論である。一方三元論の記号論の代表はソシュールと同時代に活躍したパースに見いだせる。パースの三元論は記号を対象、解釈項、表意体から成るものとして定義する。

#### 2-1-2 パースの三元論

まずはパースの三元論について紹介する。パースの三元論は先程紹介したように、対象、解釈項、表意体から成る。

![keisann-ページ17 drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/d9fc9858-9a27-4d68-8e57-be01164b662a)

それぞれの意味は以下である。

```console
表意体: 表現に対する要素
解釈項: 対象を認知するための解釈
対象: 記号が指し示す具体的な実体や事象
```

図において、表意体と対象が点線なのは表意体を通して対象は認知しうるものの、対象は解釈項を通して意味を為すことを表すためである。

ここで生じる問題は、記号という同じ概念を扱っているのにも関わらず、どうして二元論と三元論という別の理論が成り立っているかということである。これをプログラミング言語を使ってみていきたい。

#### 2-1-3 プログラミング言語における二元論と三元論

以下二元論と三元論をそれぞれ、関数型プログラミング言語とオブジェクト指向言語で表す。

以下がlisp(scheme)による二元論的コードである。

```lisp
(define (rectangle width height)
  (list rectangle width height))

(define (ellipse width height)
  (list ellipse width height))

(define (area shape)
  (match shape
    [(list rectangle width height) (* width height)]
    [(list ellipse width height) (/ (* pi width height) 4.0)]))

(define shapes
  (list (rectangle 5.0 8.0)
        (ellipse 3.0 4.0)))

(for-each (lambda (s)
            (display (string-append "area: " (number->string (area s)) "\n")))
          shapes)
```

以下がrubyによる三元論的コードである。

```rb
class Shape
  attr_accessor :width, :height
  def initialize(width, height)
    @width, @height  = width, height
  end

  def area = @width * @height
end

class Rectangle < Shape
  def initialize(width, height) = super
end

class Ellipse < Shape
  def initialize(width, height) = super
  def area = Math::PI * @width * @height / 4.0
end

shapes = [Rectangle.new(5.0, 8.0), Ellipse.new(3.0, 4.0)]
shapes.each { puts "area: #{_1.area}" }
```

コードを比較しよう。lispにおけるコードはrectangleとellipseでそれぞれ、関数名と関数の中身が定義されている。関数名が能記だとすると、関数の中身が所記である。このrectangleとellipseを使う関数は、それとは別にarea関数が定義されている。

一方rubyのコードをみてみると、RectangleとEllipseというclass名があり、その中にデータ構造とarea関数が定義してある。class名が表意体、データ構造が対象、area関数が解釈項といえる。

もちろんrubyのコードにはlambdaがあるし、classも委譲をするようにすれば二元論らしく書けるので、これは作為的な区別である。ただ二元論と三元論をそれぞれプログラミングで書くと、違いはarea関数が記号に内在する(class内にある)か外在するかの違いだけだとわかる。オブジェクト指向言語も関数型言語もチューリング完全であるので、どっちも能力においては等価である。とするならば二元論と三元論は本質的に同じであるといえそうである。

#### 2-1-4 ラムダ計算と記号の再帰性

ここで二元論と三元論が能力において同じあるならば、なぜ二元論と三元論という区別が生まれたのかという疑問が湧く。それをより原初的なラムダ計算を使って説明する。

```lambda
( λx.x + 1 ) 2
=> 2 + 1
=> 3
```

ラムダ計算においては、右の項がいわば左のλ項の識別子に代入することで計算が進む（β簡約）。

ここで上記ラムダ式を分解して見ていくと、複合記号`( λx.x + 1 )`はそれ自身で他の記号と分節される。識別子`x`は２つ目の項である2が与えられ、それを簡約すること、すなわち使用によって得られる。このラムダ式をソシュールの記号論あてはめようとすると能記の部分の解釈が難しい。なので次にlambda式にletを導入する。

```lambda
let variable = 3 in λx.x + variable
```

letを導入することで能記（ここでいうとvariable）がうまく解釈しうる。variableが記号としての分節の役割を果たすと同時に、右辺で内容を定義できる。またここでは右辺でvariableが使われているので再帰的な定義である。

let式によってvariableは内容（右辺）が決まる前に、前もって投機的に宣言される。そして投機的に宣言されることで、まずをもって記号は分節され、その分節のなかで記号の内容が決まるのである。また、この投機はコンピュータでいうとメモリの割当ともいえる。非再帰的な定義では、右辺が左辺に関係なく定義できるという意味でこの投機はほとんど意味をなさない。一方再帰定義ではこの投機がなければ、右辺の内容は確定できない。

よってlet式によって、ソシュールの記号による消極的な差異の分節というのが確認できた。そして特にそれは再帰的定義によって表出した。この再帰的定義の内容は右辺の使用によって内容が確定する。三元論的に言うなれば、使用を解釈項とするならば、内容が対象である。となると再帰的定義は使用と内容が区別できず、二元論と三元論が使用（関数）の内在/外在による区別だとすれば、再帰的な定義によって二元論と三元論は統一しうる。

先程のlet式導入前の`( λx.x + 1 ) 2`という定義においても、二元論では`( λx.x + 1 ) 2`は2番目の項によって１番目のラムダ式の内容が決まるが、`( λx.x + 1 ) 2`を1つの記号とみなすなら、式`x+1`が解釈項となり、2が対象となる。つまり二元論と三元論は視点の区別から生まれた違いであるといえる。

プログラミング言語でみえたことをいうなら、自然言語においても再帰性という性質が記号の分節と内容を決めるうえでの重要な性質といえる。経験的にも再帰的、その記号のしようによって記号の内容が決まっていく、というのは記号の在り方としても根幹を成すといえそうである。『記号と再帰』においても以下のように書かれている。

> およそ人間の表現においては、記号が本来的に再帰的であり、人間の言語や表現がそのような再帰性を最大限活用した記号系となっている以上、二元論、三元論の峻別は本来難しく、形式製の高いプログラミング言語はその意味で稀有な例なのである。

#### 2-1-5 ソシュールの記号学とパースの記号過程

二元論と三元論が視点の違いであり、能力において等価であることが今まででわかった。となるとソシュールの二元論的な記号の思想を三元論的な考え方で補完できる。

ソシュールの記号論が差異による全体論的な体系によって意味を成すのに対し、パースの記号論は解釈項によって意味を成すといえる。パースの解釈項はプログラミング言語でいうと記号表現に内在する概念であった。しかしこれが決して記号に閉じたものでなく、パースは無限の記号過程（セミオーシス）として捉えていった。

以下『記号論講義』において記号過程は以下のように説明されている。

> 一つの記号は、それを解釈する記号をつくりだし、その解釈する記号をつくりだし、その解釈する記号もさらにそれを解釈する記号をつくりだしていき、そのプロセスは無限の連鎖をかたちづくっていく。このプロセスが「無限のセミオーシス」です。

記号によって分節された対象が解釈項によって把握されて、それがまた新しい解釈項を呼ぶ。解釈項は記号内容を決めるとともに、その決められた内容が新しい解釈項を生み出すと考えると、記号過程は無限の再帰的連鎖とも捉えられる。

この記号過程的な見方はメッセージを投げる主体と主体が応答に答えるという意味で、ソシュールの全体論的な記号論に付随していた静的構造支配のイメージを払拭してくれる。3部ではこの記号過程的な考え方をより拡張して社会全体の意味論について考えていく。

#### 2-1-6 プログラミングにおける記号過程

最後に補足になるが、この記号過程の二元論におけるプログラミング的表出を見ていきたい。

javascriptのライブラリであるreactはuseStateという、関数フック[16]を持っている。以下例である。

```js
import { useState } from 'react'

const [shape, setShape] = useState({ width: 3.0, height: 4.0 })
```

関数フックという名のとおり、関数型プログラミング言語的にこれを捉えるとshapeが能記、右辺が所記になる。setShapeはshapeの使用に関する記号だが、shapeに外在するという意味で二元論的である。

shapeの値を変更するには、setShapeを使う必要があるが、useStateはリアクティブであり自身の状態を保持している。状態がsetShapeによって変化すると、自身とその子コンポーネントがレンダリングされる。これは記号の使用を通じて、自身と自身をとりまく関係が再構築されることを意味する。setShapeという使用の記号は変わらないものの、状態を変化するたびに新しい状態を更新し続ける（ユーザーがアプリケーションを触り続ける限り）という意味で無限の記号過程である。

また、三元論的表出はオブジェクト指向でみられる。その他にもオブジェクト指向言語(特にruby)は、オブジェクト間のメッセージのやりとりとして良く表現[17] [18]される。オブジェクトがメッセージを投げ、そのメッセージに別のオブジェクトが応答する。応答すると返り値として別の記号が返ってくる。そしてこれの繰り返しは、まさしく記号過程であるといえる。

### 2-2 項の種類

今回からは主に記号の指し示す内容、項についての話題になる。項はここでは具体的・抽象的を含む普遍的対象のことを指す。プログラミング言語においては、アドレスを指し示すこともあれば、データそのものを指し示すこともある。この項の種類について考えていきたい。

### 2-2-1 一次性・二次性・三次性

パースは項が一次性、二次性、三次性の三種類に分類できるという。

以下一次性、二次性、三次性定義である。それぞれ①に『記号と再帰』における定義、②に『記号論講義』における定義、③にプログラミング例を記載する。

```console
■一次性
① 積極的にそして他のいかなるものをも参照せずに、そのものであるようなものの在り方である。
② 記号を生み出すも元にあるそのような物理的-物質的なあるがままの存在様態を一次性と呼んでよいでしょう
③ リテラル型。c言語でいうとint num = 42 の42部分。中身はアドレス（&num）

■二次性
① そのものが、第二のものと関係し、しかし第三のものは考慮せずに、そのものであるようなものの在り方である。
②「他」とか「比較」、「関係」、「効果」や「結果」、「依存」や「独立」、「否定」、「事実」、「経験」などという概念に現れるものの在り方は、二次性であるとパースは言います。
③ 値。c言語でいうとint num = 42のnumの部分。中身は42という値。

■三次性
① 第二のものと第三のものを互いに関係づけることによって、そのものであるようなものの在り方である。
② 「媒介」、「習慣」、「記憶」、「総合」、「法則」、「コミュニケーション」、「表意作用」、そして「記号」などの概念に現れたものの在り方は、こうした三次性を示しているとされています。
③ 型。c言語でいうとint num = 42のintの部分。中身はnumのデータ型。
```

パースはこの三項関係ですべてを表せる（普遍的範疇）といったが、なぜ3つなのか、かつ3つで表せるのかというのが疑問に残る。

### 2-2-2 プログラミング言語による項の分類

プログラミング言語で上記の疑問に取り組む。一次性、二次性、三次性ですべてを表すために、カリー化とチャーチ変換を試みる。ここでは『記号と再帰』にあわせてhaskellで説明する。型付き関数型プログラミング言語が他にないためである。

まずはカリー化である。カリー化はいわば多数引数の関数を複数の1引数の関数に変換することである。

```haskell
-- カリー化の概念
f x y => g y where g = f x

-- 例
-- ２つの引数をとる関数f
f x y = x + y
-- カリー化っぽく表現
f x = g
  where g y = x + y
```

where文を用いた構文を使うと上記になる。例でいうとfはxを受け取ると、新しい関数gを返し、関数gは引数yを取ると、x+yを計算する。このプロセスがカリー化である。rubyでもProcを使うと以下のように表せる。

```rb
add_curried = ->(x) {
  ->(y) {
    x + y
  }
}
add_3 = add_curried.call(3) # ->(y) { 3 + y }
add_3.call(4) # 3 + 4 = 7
```

カリー化の問題は再帰的定義が存在する場合に、うまく適用できないことである。なのでカリー化の前にチャーチ変換をする必要がある。チャーチの変換（不動点コンビネータ・Yコンビネータ）は不動点を求める。不動点とはf(x) = xを満たすような値xのことであり、つまりはある関数に対してその関数を適用しても変わらない点のことを指す。

そして不動点コンビネータは、ある関数に対してその不動点を計算する高階関数である。haskellの中ではfixで使えるようになっている。

```haskell
fix f = x where x = f x
```

この`fix f`は関数fの不動点を見つけるための関数である。そして`x`は`fix f`の結果として定義されており、その`x`は`f x`に等しいと定義されている。さらに具体例をみていく。

```haskell
-- ①通常の再帰定義
factorial n = if n == 0 then 1 else n * factorial (n - 1)
--  ②fixによる定義
factorial = fix (\rec n -> if n == 0 then 1 else n * rec (n - 1))
-- ③補足1: fixの定義に当てはめた形
fix (\rec n -> if n == 0 then 1 else n * rec (n - 1)) = x where x = (\rec n -> if n == 0 then 1 else n * rec (n - 1)) x
-- ④補足2: ③のxの定義
x = \n -> if n == 0 then 1 else n * x (n - 1)
```

このチャーチの変換を使うと、式をfix(再帰部分)と式(非再帰部分)に分解できる。

ここまででカリー化とチャーチの変換を見てきたが、チャーチの変換で再帰式を非再帰に分解し、非再帰式をカリー化で1次式に変換するならば、すべての式を以下の形で表せる。

```console
fix f(x)
```

ここでxをそのもので成り立つということで一次性、fがfとxをの2つの記号を使う二次性、fixは性質上f(x)という二次式を必要とするため三次性と定義できる。パースの普遍的範疇が3項関係になっている理由がわかる。

### 2-2-3 インスタンス生成と是態性の獲得

ところで項とは普遍的な対象のことである。三次性の項が再帰だとすると、最終的に再帰処理が終わると内容が得られるはずである。その再帰的処理には、ラムダ式でletを導入したみたいに投機的な何かが必要であり、それが記号である。とするならば項の三次性を実現するために記号が必要だともいえる。

『記号論講義』における三次性の記号の定義で、「媒介」・「コミュニケーション」といったものの現れ方をすることを先程述べた。こういった概念は抽象的な一方で、内容を三次性を表す記号で表さざるを得ないという点で抽象的になる。一方でこういった概念を再帰によって見直すと、例えばコミュニケーションはコミュニケーションをすることによって定義されうること、で理解しやすくなる。

また先程2-1-6みたreactのコードは、ユーザーのインタラクションを通して状態(state)と関係性(DOM,コンポーネント)に変化を起こした。これは自身の状態によって自身と自身の関係性を変化させるとともに、記号系によって項の是態（唯一無二性を指す）をプログラミング言語で実現すること、再帰的にユーザーに適した状態に近づくことを指す。

ここまでで、項の普遍的範疇が記号系によって実現され、世の中のすべてを記号過程と考えるパースの思想を捉えることができた。

## 2-3 記号系の再帰

## 参考文献

- [1] 純粋理性批判
- [2] 歴史とはなにか
- [3] 仕事としての学問、仕事としての政治
- [4] 客観性論文
- [5] 社会科学と因果分析
- [6] 一般言語学講義
- [7] 丸山圭三郎氏の『ソシュールを読む』
- [8] 一般言語学の諸問題
- [9] 言語の本質
- [10] 音と意味についての緑青
- [11] 構造人類学
- [12] 野生の思考
- [13] 記号論講義
- [14] チョムスキー
- [15]『記号と再帰』
- [16] react
- [17] RAILSガイド
- [18] オブジェクト指向設計ガイド

候補
科学革命の構造
支配の社会学
万物の黎明
システム社会学 × 3
記号論講義


small talk あらんけい
春日語
ペルシアンレッスン
sicp
言語の本質
構造人類学
省察
経営行動
バーナード
プロテスタンティズム
日本の建築、半オブジェクト
モネの連作
トマ・ピケティ
技術革新と不平等百年氏
トクヴィル
初めての構造主義
論理哲学論考、言語哲学がはじまる
『中動態の世界』
哲学探究 使用による