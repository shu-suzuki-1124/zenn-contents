---
title: "（仮）rubyのしくみと計算理論入門 part1 正規言語について"
emoji: "👏"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ruby", "計算理論", "オートマトン", "プログラミング言語"]
published: false
---

## はじめに

※ 執筆中なので引用と文体は雑。とりあえず書き切ることが目標。
※ 書いてるけど8割書き直したい。

本記事は友達のいない私が2023-2024の冬休みの自由研究の成果として書いていく記事です。
エンジニア歴も文系出身でコンピューターサイエンスやプログラミング言語に関する知識も浅いので、運悪く本記事を見てしまった方は温かい舌打ちをしながら見守ってください。

## 本記事の概要

本記事はタイトルの通り、『[Rubyのしくみ　Ruby Under a Microscope]()』と『[計算理論の基礎 1.オートマトンと言語]()』を読んで学んだことを融合して体系的に書いていきたいと思います。どっちかというと計算理論寄りの内容になります。

ただそのまま本の内容を書くのも面白くないので、「計算理論を学ぶ意義について」「具体的なプログラミング言語ではなく数学的な記号を使って言語を考えるモチベーションについて」「普段のプログラミング業務から直感的に計算理論へ辿りつく考え方」をベースに学んだ内容を再構築して行こうかなと思います。

そしてなにより業務にはそんな関係ないけど、rubyのしくみや計算理論は面白いなあと感じたことを出していきたいです。

## 目次

1. 言語とはなにか？ 〜テーマを決める〜
2. この記事のゴールと方針を設定する
3. Rubyのしくみの字句解析を部分を読む
4. 字句解析と正規表現について考える
5. 正規表現から有限オートマトンを導く
6. 有限オートマトンの例を考えてみる
7. 有限オートマトンと正規表現の性質について
8. 有限オートマトンと非決定性
9. まとめ/次回予告
10. 参考文献

## 1. 言語とはなにか？ 〜テーマを決める〜

### ⅰ. テーマを考える

本題に入る前に、考えておきたいことがあります。それは本記事を通して一貫するテーマです。
テーマの中心は【プログラミング言語】ということになりそうですが、せっかくなので脱線してもうちょっと深堀って考えてみましょう。

実はですが私が本記事のタイトルでもある、『Rubyのしくみ』や『計算理論』に興味を持ったのはプログラミングではないところから来ていて、言語哲学や言語学に関しての本を読んでいたのがきっかけです。【言語】そのものに関する疑問が【プログラミング言語】に対して考えられるのではないか、というふうに思ったのです（もちろん言語哲学も言語学もコンピューターサイエンスに多大な影響を与えてはいるのでプログラミングに関係ないとは言い切れませんが....）。なのでここで軽く言語哲学と言語学について紹介したいと思います。これらの学問の問いを抽出することで、それを「プログラミング言語」への問いとし、それを本記事のテーマとしたいと思います。

### ⅱ. 言語哲学/言語学とはなにか

※かなりざっくり説明しているので、各説明は厳密にいうと違う部分も多いかと思いますがご了承ください。

#### 言語哲学

哲学とは超ざっくり言えば、人間とはなにか、人間の認識や思考の本質とはなにかに関する学問です。そして言語哲学とはそういった哲学の問題を考えるために言語を中心に据えたものです（言語論的転回ともいいます）。言語哲学といえば、ゴットロープ・フレーゲやバートランド・ラッセルといった人物も挙げられますがが、なによりも有名なのはルートヴィヒ・ウィトゲンシュタインでしょう。そのウィトゲンシュタインの代表的著作が『論理哲学論考』です。

では『論理哲学論考』はどういった著書かといいますと、解釈によっては様々な意見はあるかと思いますが、『思考の限界について、言語の限界を通して思考する』という内容です。もう少し詳しく説明しましょう。岩波文庫で『論理哲学論考』の翻訳をされている野矢茂樹氏の著書『論理哲学論考を読む』では以下のような記述があります。

> いま確認されたことは次の二点である。(1) 思考可能性の限界を思考によって画定することはできない。他方、(2) 言語の有意味性の限界ならば画定可能である。....

つまり、思考の限界は思考の限界の外に属せない人間にとって考えることはでません（思考の外側を考えることは結局思考することになってしまいます）。一方で言語が意味を為すか為さないかは理解できそうです。直感的にも我々は思考するとき意味のある言葉を使って思考をすると思いますが、その意味のある言葉がどういう風に決まるかわかれば、それは即ち思考の限界についてわかることになるのではないのでしょうかという内容です。

詳しくは原著や上記で紹介した野矢茂樹氏の著書等をお読みくださいませ。ちなみに私は『論理哲学論考』に出会って早７年ですが、全然理解できてません。

#### 言語学

先ほど上げた言語哲学も含め、言語に関する問題は古代ギリシアからあらゆる時代、あらゆる学者・哲学者によって考えらました。その中でも現代の言語の研究において最も影響を与えた一人として挙げられるのは、フェルディナン・ド・ソシュールといって間違いないでしょう。

ではソシュールの言語学はいったいどういうものでしょうか。ソシュールの著書事象は少しややこしいのですが、その講義内容は『一般言語学講義』にまとめられています。ソシュールの革新性といえば、言語学の対象、言語そのものを研究の対象にしたことでしょう。ソシュール以前の言語に関する研究は、特定の具体言語やその比較、言語の歴史的変遷に関わる研究でした。そういった研究をソシュールは通時的と分類する一方で、共時的言語のあり方、すなわち非歴史的な言語の構造的なあり方、各具体言語に共通する言語の性質について研究しました。その研究によって言語の記号的な性質が言語学の対象になっていきました。

ソシュールの後継者とも言われるE・バンヴェニストは『一般言語学の諸問題』にてソシュールを以下のように評しています。

> 今日彼に何物かを負うていない言語学者はありません。彼のなを引かない一般理論はありません。

> ...すなわち次の二問を私達はソシュールの学理の中心にあるものとするのであります。
> 1 言語学が倣って立つべき基本的な所与はどのようなものであるか？いかにすればかような所与に達することができるか
> 2 ことばのもつ諸観念はどのような性質のものであるか？それらはどのような関係によって分節されるのであるか？

ソシュールのそういった研究が、R・ヤーコブソンの『音韻論』やN・チョムスキーの『生成文法』の議論へと発達し、現代のコンピュータ言語に対しての発展にも寄与しています。チョムスキーに関しては文脈自由言語のところで再度紹介するつもりです。

#### 言語哲学/言語学から抽出される問い

上記で紹介した学問の問いを【プログラミング言語】に単純にあてはめて簡単に導出するなら、言語哲学からは『**①プログラミング言語の限界はなにか、プログラミング言語で考えることの限界はなにか**』、言語学からは『**②プログラミング言語に共通する性質はなにか**』という2点が抽出されるのではないでしょうか。

この2点をもって本記事のテーマとしたいと思います。もちろんこの話題はすでに多くの研究者によって研究されていますし、内容も高度で私に完全に手に追えるものとも思いません。ただその入門中の入門であれば少しは考えることができるのではないかと思いました。

### ⅲ. 計算理論について

ここで計算理論についても、軽く触れておきたいと思います。
memo: チューリングマシン

今回のテーマは先程述べたように【プログラミング言語】に関して、すなわち【プログラミング言語】を考えるうえでの数学的モデルのお話ですが、計算理論自体は【プログラミング言語】以外にも関わる幅広い学問です。

『[計算理論の基礎 1.オートマトンと言語]()』では以下のような説明がされています。

「初版へのまえがき」より

> この科目では、計算機のハードウェア、ソフトウェア、およびそれらの応用に関する基本な数学的性質について学びます。具体的には、何を計算できて何を計算できないか？また、どれくらい速く、どれくらいのメモリ使用量で計算できるか？さらには、そうした計算が、どのタイプの計算モデルで可能となるのか？などについて学びます。

「0: 序論」より

> 本書は、計算の理論の重要な柱を為す3つの分野: オートマトン、起算可能性、複雑さについての教科書である、これら３つの分野はすべて 計算機の本質的な能力とその限界は何か？という疑問に関係している

本記事では特にオートマトンの分野を取り上げます。上記の説明の通り、【プログラミング言語】を処理するモデルが示せれば、そのモデルの限界についても理解できますし、そのモデルを通して性質についても考えられます。限界を知ることは『ソフトウェアアーキテクチャの基礎』や『ソフトウェアアーキテクチャハードパーツ』のキーワードでもある「トレードオフ」を知ることにほかなりません。

先ほど上げた言語学も計算理論に多大な影響を与えていますし、その逆もまた然りです。
では長くなってしまいましたが本題に入っていきましょう。

## 2. この記事のゴールと方針を設定する

とその前に方針とゴールについて考えましょう。繰り返しになりますがテーマは

- **①プログラミング言語の限界はなにか、プログラミング言語で考えることの限界はなにか**
- **②プログラミング言語に共通する性質はなにか**

です。そして前提としては本記事は入門記事です。上記の質問に完全に応えるのは相当難しいので導入部分のみになります。その導入を少しばかり工夫してみましょう。なので普段コンピューターサイエンスの理論に馴染みはないけど、プログラミングを書いているような方が、自然と導入できるような論理構成でいければなと思います。

そして何よりもゴール設定です。なにをもって２つの設定したテーマに近づけるかということですが、ここではゴールを「数学的記号で性質を表す」ことにします。ちょっと無理矢理感というかこじつけ感あるかもですが、プログラミング言語でプログラミング言語の性質を考えるのは難しです。そこで数学的記号、特に特に『集合』と『関数』によってその性質を答えることが有効そうです。というのも集合とは要素の集まりで関数は規則のことです。これらで定義できれば性質が理解できたことになり、その集合以外や関数で表せないものを考えることで限界について考えるっことができそうです。

もちろんここで紹介するのは字句解析と構文解析あたりのみなので、完全には答えられませんが、導入としては十分でしょう！

## 3. Rubyのしくみの字句解析を部分を読む

では早速本題にはいりましょう！

### ⅰ. Rubyのコードが実行されるまで

『rubyのしくみ』の最初をみてみますと、こんなことが書いてあります。

> プログラムを実行する手前で、Rubyは何回コードを読み、変換しているだろう？１回？それとも２回？
正解は3回だ。

そしてその後にこのような図があります。

```mermaid
graph LR
A(Rubyコード) --> B[字句解析]
B --> C[構文解析]
C --> D[コンパイル]
D --> E(YARV命令)
```

これがrubyという言語が認識されて実行される道のりです。

### ⅱ. どうして変換が３つに分かれているか

『Rubyのしくみ』では上記の図のあとはそれぞれの説明に入っていきますが、少しここで立ち止まって考えましょう。

どうして３つに分かれているでしょうか？それは単純に考えればそれぞれ役割が違うからです。それは間違いなさそうです。では穿った見方をするとどうでしょう？裏にある構造/性質が異なるため３つに分けざるを得なかったと考えることもできそうです。

簡単なものであればワンステップでもいけるでしょうし、言語によってはステップ数が異なることもあるでしょう（そこらへん詳しくないのでわからないですが...）。一方で個々の言語処理は個別的な一方で多くの言語では字句解析と構文解析のステップがありそれが分離しています。ここに何か必然的合理性がありそうです。

となると本記事の目標は数学的記号でプログラミング言語の性質を表すことです。上記の理由からこの3ステップは別々の数学的モデルが存在し、別々に見ていく必要がありそうです。なのでまずは字句解析から考えていきます。

## 4. 字句解析と正規表現について考える

### i. 字句解析はなぜ必要か

『Rubyのしくみ』では第1章のはじめに字句解析について解説しています。そもそも字句解析とはなんのために行われるか。

> 字句解析では、ソースコード内のテキストを読み込み、それらをRuby言語内で使われる単語の列、トークン列へと変換する。

> ...すなわち、ひとまとまりに読んで理解が可能な単語の列、トークン列へと文字を変換する

すなわち図式化するならば

```mermaid
graph LR
A(我々書いたRubyコード) -->|字句解析| B[構文解析用に各文字をトークン化]
```

という図式になりそうです。となるとこの字句解析は何か一定の規則をもってトークン化してそうです。

### ii. 字句解析はどんな処理をしているかrubyで考える

内部の処理をここでは私達がいつも使っているプログラミングでどうやって処理するか考えてみましょう。

#### パターン① 一般的なrubyだけで考えてみる

ここでは『rubyのしくみ』と同じで、`10.times do |n|` という文字をトークン化する処理を考えましょう

普通にrubyだけで構築するならこんな感じの実装が考えられます。

```rb
# 文字をtokenに変えるための参照先
str_hash = {
  "10" => "tInteger",
  "times" => "tIDENTIFIERtimes",
  "." => ".",
  "do" => "keyword_do",
  "|" => "|",
  "n" => "tIDENTIFIERn"
}

tokens = []
tmp_ary = []

str = "10.times do |n|"

str.each_char do |s|
  if s == "." || s == "|"
    tokens << str_hash[tmp_ary.join] unless tmp_ary.empty?
    tokens << str_hash[s]
    tmp_ary = []
  elsif s == " "
    tokens << str_hash[tmp_ary.join]
    tmp_ary = []
  else
    tmp_ary << s
  end
end

tokens << tmp_ary.join unless tmp_ary.join.empty?

puts "トークンの中身は#{tokens}です"
# トークンの中身は["tInteger", ".", "tIDENTIFIERtimes", "keyword_do", "|", "tIDENTIFIERn", "|"]です
```

`str_hash`はruby内部にあるとして所与のものとして、その他のロジックをみてくださいませ。
まあ動きはますが複雑な上に、これ以上文字増えたらえげつないことになりそうです。

少しでもエンジニア経験ある方ならこんなことせずに、正規表現を使うことを思いつくでしょう。次に正規表現について考えましょう。

#### ②正規表現で実装してみる

次は正規表現を使って①のコードをリファクタリングしてみましょう。

```rb
str_hash = {
  "10" => "tInteger",
  "times" => "tIDENTIFIERtimes",
  "." => ".",
  "do" => "keyword_do",
  "|" => "|",
  "n" => "tIDENTIFIERn"
}

str = "10.times do |n|"

tokens = str.scan(/\w+|\.|\|/).map { |token| str_hash[token] || token }

puts "トークンの中身は#{tokens}です"
# トークンの中身は["tInteger", ".", "tIDENTIFIERtimes", "keyword_do", "|", "tIDENTIFIERn", "|"]です
```

どうでしょう！だいぶシンプルになりましたね。`str_hash`を今回自分で書いてるのであれですが、ロジックの部分に関していえばある程度単語の種類や文字列の拡張にも耐えれそうです。

ここで導き出せる帰結は、字句解析の処理と正規表現の処理が直感的に相性がいいということです。正規表現は文字列マッチングなのですから当然といえば当然です。

我々の目標はいつも使っているプログラミング言語を数学的記号で置き換えることです。
今度は今見た正規表現についてその性質を深堀ってみましょう。字句解析と正規表現は相性がいいのであれば、その裏側にある構造は同じと予想できます。そしてその予想は実際正しいのです。なので正規表現を掘り下げることで目標に近づきましょう！

## 5. 正規表現から有限オートマトンを導く

### i. 正規表現を分解してみる

さて先程使った`/\w+|\.|\|/`という正規表現について考えてみましょう。
`\w`を省略せずに書くと`/[a-zA-Z0-9_]+|\.\|/`となるので、こっちの直感的な記法を考えてみましょう。

意味としては、この正規表現は「1文字以上の英数字（`/[a-zA-Z0-9_]+`）、または(`|`)ピリオド(`\.`)、または(`|`)パイプ文字(`\|`)のいずれか」にマッチするというものです。

普段であれば意味さえわかれば良いとは思いますが、正規表現がどんな要素から成立しているか考えてみると以下のようになりそうです。

① 文字要素: 「a」や「6」などの1つ1つの文字。今回で言えば(`[a-zA-Z0-9_]`部分とドットとパイプ文字)
② 規則要素: 「+」の繰り返しや「|」のまたはを意味する記号。

何回もいいますが、我々の目標はいつも使っているプログラミング言語を数学的記号で置き換えることです。
とするとここで①は**集合**と考えられないでしょうか。すなわち言い換えるなら今回の正規表現の文字要素は「小文字と大文字のアルファベット数値とドットとパイプ文字の集合」から成立するといえないでしょうか。

もう少し数学っぽく表現するなら、集合Aを`{a, b, c, ...., A, B, C, ....., 1, 2, 3..., ., |}`とするなら、先程の正規表現は集合Aの要素から成り立つといえそうです。

そして②の規則要素は数学っぽく表現するなら**関数**といえそうです。関数はプログラミングでもよく使うので直感的に理解できそうです。数学的に書くなら関数y=f(x)はある入力xに対して、一定の規則で出力するｙを生成します。今回の`+`であれば①の集合の要素を1文字以上連続で出力する関数といえそうです。

ここまでをまとめるなら、正規表現は数学的記号である**集合**と**関数**に分解できるということです。

### ⅲ. 字句解析の順序を振り返る。状態の導入

正規表現は**集合**と**関数**に分解できることを学びました。数学的定義にたどり着くまでもう一歩！

『rubyのしくみ』では字句解析の解説でこんな感じの図が使われています。

「1」を読み込む
![ruby drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/b30e2673-d818-461a-9056-dd1fb8b2391e)

「0」を読み込む
![ruby2 drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/0dd40f49-3537-4a80-9649-69773345809d)

大事なのは図中の矢印のところです。簡単にいえばその処理がどこまで進んだかを把握する必要があります。ただ難しく考える必要はありません。これもどこまで文字を読みん混んだかという**状態の集合**として数学的記号で表せるからです。{1文字目まで読み込んだ状態, 2文字目まで読み込んだ状態, 3文字目まで読み込んだ状態....}みたいな感じです。

ただ文字数が多くなってくると1文字1状態はきついので少し工夫が必要です。その工夫とは読み込まれた要素によって、規則の出力が変わる場合です。簡単にいえば`/[a-zA-Z0-9_]+`は0でもaでも適用される規則は変わらないので、規則が適用される前の状態から適用された状態がaも0も同じなので状態を分ける必要はありません。

ここは図示すればわかりやすいと思うので次に図示してみましょう。

### ⅳ. 遷移図を描く

図を書くためには3つの要素が必要でした。

- ① 要素の集合
- ② 関数
- ③ 状態の集合

です。これを念頭に図を書いてみましょう。

#### 【part1】: 「times」を認識する図を書く

まずは`10.times do |n|` の`times`だけを読み取るような図をかいてみましょう

- ① 要素の集合: {t, i, m, e, s}
- ② 関数: t→i→m→e→sの順番どおりに遷移する
- ③ 状態の集合 文字を何個目まで読み込んだか。文字が5文字なので「状態1」〜「状態5」までにしてみましょう。

図にするとこんな感じになります。

![times drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/7c7c8dd3-4e0f-4b1a-a599-63b913567694)

③の状態に1つ「スタート状態」を付け加えました。これはまだ文字が何も読まれていない状態という意味です。
そして図はスタート状態から「t」が読み込まれたら状態1へ、その次にiが読み込まれたら状態2へ...という風に遷移していきます。
単純な図ですね。

ここで1つ問題があります。例えばtの後の文字がsだったらどうでしょう？iの後がtだったらどうでしょう。
この図だと表せてませんね。少し改良しましょう。

![times2 drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/93929c26-594e-4632-9265-c2ea5c938de0)

ボツ状態を加えました。例えば「状態1」つまりtが読み込まれたあとにその次がiだった場合は状態2へ、それ以外の「t,m,e,s」の要素だったらボツ状態にいくようにします。（「t, i, m, e, s」以外のアルファベットは①の定義によって受け付けません。）

こうやってみると文字を全部入力し終えて、状態5にいるなら`times`という文字が読み込まれたとわかります。反対にボツ状態にいるときは`times`以外の文字が読み込まれたと言えそうです。

#### 【part2】: 状態数を減らしてみる

我々の目標は`/[a-zA-Z0-9_]+|\.\|/`を図にすることでした。同じ要領でやってみましょう。

- ① 要素の集合: {a..z, A..Z, 0..9, 「.」, 「|」}
- ② 関数: {a..z, A..Z, 0..9}の要素であれば1文字以上の繰り返す、「.」「|」であれば1文字のみ。
- ③ 状態の集合 {a..z, A..Z, 0..9}を受け付ける状態（1文字以上の場合はその状態に自己ループする）。「.」「|」を受け付ける状態。

こちらも早速図で表してみましょう。

![final drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/e8148e15-12b1-42a8-9fed-b1330a52fd1b)

{a..z, A..Z, 0..9}の要素の1文字目で状態Aへ以降し、2文字目の{a..z, A..Z, 0..9}の要素は状態Aから状態Aに遷移します。
「.」「|」はそのまま状態Bに遷移します。

この図の場合は状態Aか状態Bに入力にいればOKです。

このように図にすることで、文字を解析する構造が集合と関数で表せることがわかりやすくなります。

### ⅳ. 有限オートマトンを定義する

ここまでの流れを一旦復習しておきましょう。

まずは`10.times do |n|`を字句解析するためにどんな方法があるか考えました。rubyのコードを単純に書くだけでもできなくもないですが、正規表現を使えば簡単に書けることがわかりました。となると字句解析と正規表現の構造は似ているのではという仮説を立てて、正規表現の構造を分解してみました。そうするの正規表現は「集合」と「関数」という数学的記号の集まりで、できているというアイデアが発見されて、その「集合」と「関数」を使えば字句解析または正規表現を表す図が簡単にできることが判明しました。

ここから導きだせるのは、字句解析や正規表現の構造は集合と関数によって表現しうることです。そしてその表現を計算理論では**有限オートマトン**といいいます。

そしてここに有限オートマトンの正式な定義を定義します。

*************************************************************

有限オートマトンは5個組($Q$, $\sum$, $\sigma$, $q_0$, $F$)であり、

- $Q$: 状態の有限集合
- $\sum$: アルファベット（要素）の有限集合
- $\sigma$: 遷移関数　$Q \times \Sigma \rightarrow Q$
- $q_0$: 開始状態。ただし$q_0 \in Q$。
- $F$: 受理状態の集合。ただし$F \subseteq Q$。

とする。
*************************************************************

ちょっといきなり数学的な記号ばっかでびっくりしますが、内容はさきほど説明したものと同じです。
`/[a-zA-Z0-9_]+|\.\|/`の正規表現をこれにあてはめてみましょう。

$Q$は要素の集合のことですから、さっきの図でいうと{スタート状態,状態A,状態B}のことですね。$\sum$は要素のことですから、{a..z, A..Z, 0..9, 「.」, 「|」}のことです。遷移関数は正規表現の+とかの規則の部分です。$Q \times \Sigma \rightarrow Q$というのは、とある状態の時(1つめのQ)のとき、特定のアルファベット（要素）を与えると、別の状態（右側のQ,自己ループのときは同じ）に遷移するという意味です。$q_0$はそのままスタート状態です。$F$は受理状態の集合なのでさっきの例でいうと状態Aと状態Bのことになります。

またさっき定義する前に使った図を遷移図といいます。遷移図は視覚的に理解しやすいのでよくつかいます

具体例をみればもうちょっとわかりそうです。なので有限オートマトンの具体例をみて理解しましょう。そのあとで有限オートマトンの性質について吟味して、正規表現との関係も考察していきましょう。

## 6. 有限オートマトンの例を考えてみる

いくつか遷移図と定義の具体例をみていきましょう

### 例１: 001が入る文字列を受理するオートマトン

文字列の中に「001」が入る文字を受理する有限オートマトン$M$

$M$の定義を以下とする

- $Q$: $q$,$q_0$, $q_{00}$, $q_{001}$
- $\sum$: {0, 1}
- $\sigma$: 図を参照。（図か表で書くのがだいたいわかりやすい）
- $q_0$: $q$。
- $F$: {$q_{001}$}

![001 drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/3088cbf2-064e-4b5d-8e19-330aa221747a)

### 例2: さっきの『rubyのしくみ』で使ったやつを拡張してみる

rubyにはインスタンス変数(ex: @user)やクラス変数(ex: @@user)がありますよね。この@は先頭ならば許可しますが、文中は許可しません。
よって有限オートマトン的に言えば@は要素だが、関数に制約があるといえそうです。正規表現で表すならば`/(@{0,2}\w+)|\.|\|/`こんな漢字です。

この文法を加えて改良した有限オートマトンを定義してみましょう。

- $Q$: {スタート状態, 状態A, 状態B, 状態C}
- $\sum$: {a..z, A..Z, 0..9, 「.」, 「|」, 「@」}
- $\sigma$: 図を参照。（図か表で書くのがだいたいわかりやすい）
- $q_0$: スタート状態
- $F$: {状態A}

![keisann-ページ4 drawio](https://github.com/shu-suzuki-1124/zenn-contents/assets/103195099/2b534619-84af-48eb-b9fd-879c78947e00)

memo: 図はあとで作り直す。説明も修正追加をあとでする。

このように集合と関数を変えるだけでいろんなパターンを認識できる有限オートマトンができあがります。
少し思考実験で有限オートマトンのアルファベットを英数字や記号全てにし、いつも使っているrubyの命名規則を関数とするならrubyの字句解析がなんとなく見えてきそうです。

なので今度はこの有限オートマトンの性質を少し深ぼってみましょう。そうすることでより理解が深まります。

## 7. 有限オートマトンと正規表現の性質について
